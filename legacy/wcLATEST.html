<!-- index.html -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DodecaTone</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <h1>DodecaTone (SYNTHESIS)</h1>
    
    <div id="options-container">
        <div class="select-group">
            <label for="layout-select">Layout:</label>
            <select id="layout-select">
                <option value="chromatic">Chromatic</option>
                <option value="fifths">Fifths</option>
                <option value="fourths">Fourths</option>
            </select>
        </div>

        <div id="tonic-selector">
            <button id="decrease-tonic">&lt;</button>
            <span id="current-tonic">C</span>
            <button id="increase-tonic">&gt;</button>
        </div>

        <div class="select-group">
            <label for="pattern-select">Pattern:</label>
            <select id="pattern-select">
                <option value="none">None</option>
                <option value="major">Major Scale</option>
                <option value="minor">Minor Scale</option>
                <!-- Add more scale options here -->
            </select>
        </div>
    </div>

    <div id="content-container">
        <div id="main-content">
            <div id="wheel-container">
                <!-- Wheel will be inserted here by JavaScript -->
            </div>
            <div id="keyboard-container">
                <!-- Keyboard will be inserted here by JavaScript -->
            </div>
        </div>
        <div id="toggles-panel">
            <h3>Settings</h3>
            <div class="toggle-group">
                <label for="toggle-sharps">Use Sharps:</label>
                <input type="checkbox" id="toggle-sharps">
            </div>
            <div class="toggle-group">
                <label for="toggle-colors">Use Colors:</label>
                <input type="checkbox" id="toggle-colors">
            </div>
            <div class="toggle-group">
                <label for="toggle-animate">Animation:</label>
                <input type="checkbox" id="toggle-animate">
            </div>
            <button id="toggle-debug">Toggle Debug Dashboard</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script type="module" src="app.js"></script>
</body>
</html>

<!-- styles.css-->

body {
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    background-color: #f0f0f0;
}

#options-container {
    display: flex;
    justify-content: space-between;
    width: 100%;
    max-width: 800px;
    margin-bottom: 20px;
}

#toggles-panel {
    width: 200px;
}

.toggle-group {
    margin-bottom: 10px;
}

select, button {
    padding: 5px 10px;
    margin: 5px;
}

input[type="checkbox"] {
    margin-right: 5px;
}

#content-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%;
    max-width: 800px;
}

#main-content {
    flex: 1;
    margin-right: 20px;
}

#wheel-container {
    width: 300px;
    height: 300px;
    margin-bottom: 20px;
}

#keyboard-container {
    width: 100%;
    height: 150px;
    position: relative;
}

.keyboard {
    position: relative;
    width: 100%;
    height: 100%;
    align-items: center;
    justify-content: center;
}

.key {
    position: absolute;
    width: 40px;
    height: 150px;
    border: 1px solid #000;
    box-sizing: border-box;
    display: flex;
    justify-content: center;
    align-items: flex-end;
    padding-bottom: 10px;
    cursor: pointer;
}

.key.white {
    background-color: #fff;
    z-index: 1;
}

.key.black {
    background-color: #333;
    height: 100px;
    width: 20px;
    z-index: 2;
}

.key.active {
    background-color: #ffd700;
}

.note-display {
    font-size: 12px;
    color: #000;
}

.key.black .note-display {
    color: #fff;
}

/* Styles for the wheel */
#wheel-container svg {
    width: 100%;
    height: 100%;
    border: 1px solid #000;  /* Add a border to see the SVG boundaries */
    
}    

#wheel-container svg * {
     visibility: visible !important;  /* Force all SVG elements to be visible */
}


.note circle {
    stroke-width: 2;
}

.note text {
    font-size: 14px;
}

// app.js

import * as config from './config.js';
import { Wheel } from './wheel.js';
import { Keyboard } from './keyboard.js';

// Initialize Tone.js
const synth = new Tone.PolySynth(Tone.Synth).toDestination();

// Global state
let currentLayout = 'chromatic';
let currentPattern = 'none';
let currentTonic = 'C';
let useSharps = false;
let useColors = false;
let debugMode = false;
let animate = false;

// Initialize components
const wheel = new Wheel(document.getElementById('wheel-container'));
const keyboard = new Keyboard(document.getElementById('keyboard-container'));

function updateLayout(newLayout) {
    currentLayout = newLayout;
    wheel.updateNotePositions(config.layouts[currentLayout], true);
    keyboard.updateKeyPositions(config.layouts['chromatic']);
    updateAllNoteStates();
}

function updateTonic(direction) {
    const currentIndex = config.notes.indexOf(currentTonic);
    const newIndex = (currentIndex + direction + 12) % 12;
    currentTonic = config.notes[newIndex];
    document.getElementById('current-tonic').textContent = config.getNoteDisplay(currentTonic, useSharps);
    const rotationDegrees = newIndex * -30;
    wheel.rotateWheel(rotationDegrees, true);
    updateAllNoteStates();
}

function updatePattern(newPattern) {
    currentPattern = newPattern;
    const patternNotes = config.scales[currentPattern] || [];
    wheel.updatePatternShape(patternNotes);
    updateAllNoteStates();
}

function toggleSharps() {
    useSharps = !useSharps;
    document.getElementById('current-tonic').textContent = config.getNoteDisplay(currentTonic, useSharps);
    updateAllNoteStates();
}

function toggleColors() {
    useColors = !useColors;
    updateAllNoteStates();
}

function toggleAnimation() {
    animate = !animate;
}

// Add event listener
document.getElementById('toggle-animate').addEventListener('change', toggleAnimation);

function updateAllNoteStates() {
    config.notes.forEach((note, noteId) => {
        const state = getNoteState(note);
        wheel.updateNoteState(noteId, state, useColors);
        keyboard.updateKeyState(noteId, state, useColors);
    });
}

function getNoteState(note) {
    const noteId = config.notes.indexOf(note);
    const patternNotes = config.scales[currentPattern] || [];
    return {
        display: config.getNoteDisplay(note, useSharps),
        color: useColors ? config.noteColors[note] : (note.includes('/') ? '#333' : '#fff'),
        active: note === currentTonic,
        inPattern: patternNotes.includes(noteId),
        isTonic: note === currentTonic
    };
}

function playNote(note) {
    const toneNote = note.replace('♯', '#').replace('♭', 'b').split('/')[0] + '4';
    synth.triggerAttackRelease(toneNote, '8n');
    const noteId = config.notes.indexOf(note);
    const state = { ...getNoteState(note), active: true };
    wheel.updateNoteState(noteId, state, useColors);
    keyboard.updateKeyState(noteId, state);
}

function stopNote(note) {
    const toneNote = note.replace('♯', '#').replace('♭', 'b').split('/')[0] + '4';
    synth.triggerRelease(toneNote);
    const noteId = config.notes.indexOf(note);
    const state = getNoteState(note);
    wheel.updateNoteState(noteId, state, useColors);
    keyboard.updateKeyState(noteId, state);
}

document.addEventListener('DOMContentLoaded', () => {
    wheel.initialize();
    keyboard.initialize();

    updateLayout(currentLayout);
    updatePattern(currentPattern);

    // Event listeners
    document.getElementById('layout-select').addEventListener('change', (e) => updateLayout(e.target.value));
    document.getElementById('decrease-tonic').addEventListener('click', () => updateTonic(-1));
    document.getElementById('increase-tonic').addEventListener('click', () => updateTonic(1));
    document.getElementById('pattern-select').addEventListener('change', (e) => updatePattern(e.target.value));
    document.getElementById('toggle-sharps').addEventListener('change', toggleSharps);
    document.getElementById('toggle-colors').addEventListener('change', toggleColors);
    document.getElementById('toggle-debug').addEventListener('click', toggleDebugDashboard);

    // Set up note playing events
    wheel.container.addEventListener('mousedown', (e) => {
        const noteElement = e.target.closest('[data-note-id]');
        if (noteElement) {
            const noteId = parseInt(noteElement.getAttribute('data-note-id'));
            playNote(config.notes[noteId]);
        }
    });

    wheel.container.addEventListener('mouseup', (e) => {
        const noteElement = e.target.closest('[data-note-id]');
        if (noteElement) {
            const noteId = parseInt(noteElement.getAttribute('data-note-id'));
            stopNote(config.notes[noteId]);
        }
    });

    keyboard.keyboardElement.addEventListener('mousedown', (e) => {
        const keyElement = e.target.closest('[data-note-id]');
        if (keyElement) {
            const noteId = parseInt(keyElement.getAttribute('data-note-id'));
            playNote(config.notes[noteId]);
        }
    });

    keyboard.keyboardElement.addEventListener('mouseup', (e) => {
        const keyElement = e.target.closest('[data-note-id]');
        if (keyElement) {
            const noteId = parseInt(keyElement.getAttribute('data-note-id'));
            stopNote(config.notes[noteId]);
        }
    });
});

function toggleDebugDashboard() {
    debugMode = !debugMode;
    const dashboard = document.getElementById('debug-dashboard');
    if (debugMode) {
        updateDebugDashboard();
        dashboard.style.display = 'block';
    } else {
        dashboard.style.display = 'none';
    }
}

function createDebugDashboard() {
    const dashboard = document.createElement('div');
    dashboard.id = 'debug-dashboard';
    dashboard.style.cssText = `
        position: fixed;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-family: monospace;
        z-index: 9999;
    `;
    document.body.appendChild(dashboard);
    return dashboard;
}

function updateDebugDashboard() {
    const dashboard = document.getElementById('debug-dashboard') || createDebugDashboard();
    
    dashboard.innerHTML = `
        <h3>Debug Dashboard</h3>
        <pre>
App State:
  Current Layout: ${currentLayout}
  Current Pattern: ${currentPattern}
  Current Tonic: ${currentTonic}
  Use Sharps: ${useSharps}
  Use Colors: ${useColors}

Wheel:
  Note Elements: ${wheel.noteElements.size}
  Note Positions: ${wheel.notePositions.size}

Keyboard:
  Key Elements: ${keyboard.keyElements.size}
        </pre>
    `;
}

export { playNote, stopNote };

// config.js

// Basic note array
const notes = ['C', 'C♯/D♭', 'D', 'D♯/E♭', 'E', 'F', 'F♯/G♭', 'G', 'G♯/A♭', 'A', 'A♯/B♭', 'B'];

// Function to generate layout based on interval
const generateLayout = (interval) => {
  return Array.from({ length: 12 }, (_, i) => notes[(i * interval) % 12]);
};

// Layouts
const layouts = {
  chromatic: notes,
  fifths: generateLayout(7),
  fourths: generateLayout(5)
};

// Function to get note display based on sharp/flat preference
const getNoteDisplay = (note, useSharps) => {
  if (note.includes('/')) {
    return useSharps ? note.slice(0, 2) : note.slice(-2);
  }
  return note;
};

// Scales
const scales = {
  none: [],
  chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
  major: [0, 2, 4, 5, 7, 9, 11],
  minor: [0, 2, 3, 5, 7, 8, 10],
  harmonicMinor: [0, 2, 3, 5, 7, 8, 11],
  melodicMinor: [0, 2, 3, 5, 7, 9, 11],
  pentatonicMajor: [0, 2, 4, 7, 9],
  pentatonicMinor: [0, 3, 5, 7, 10],
  blues: [0, 3, 5, 6, 7, 10],
  wholeTone: [0, 2, 4, 6, 8, 10],
  diminished: [0, 2, 3, 5, 6, 8, 9, 11],
  augmented: [0, 3, 4, 7, 8, 11]
};

// Chords
const chords = {
  major: [0, 4, 7],
  minor: [0, 3, 7],
  diminished: [0, 3, 6],
  augmented: [0, 4, 8],
  sus2: [0, 2, 7],
  sus4: [0, 5, 7],
  major7: [0, 4, 7, 11],
  minor7: [0, 3, 7, 10],
  dominant7: [0, 4, 7, 10],
  diminished7: [0, 3, 6, 9],
  halfDiminished7: [0, 3, 6, 10]
};

// Modes
const modes = {
  ionian: scales.major,
  dorian: [0, 2, 3, 5, 7, 9, 10],
  phrygian: [0, 1, 3, 5, 7, 8, 10],
  lydian: [0, 2, 4, 6, 7, 9, 11],
  mixolydian: [0, 2, 4, 5, 7, 9, 10],
  aeolian: scales.minor,
  locrian: [0, 1, 3, 5, 6, 8, 10]
};

// Regulars
const regulars = {
  one: scales.chromatic,
  two: scales.wholeTone,
  three: chords.diminished7,
  four: chords.augmented,
  five: layouts.fourths,
  six: [0,6]
}

// Note colors (ordered chromatically)
const noteColors = {
  'C': '#E25A5A',
  'C♯/D♭': '#5AA1E2',
  'D': '#E2E25A',
  'D♯/E♭': '#9E5AE2',
  'E': '#5AE25A',
  'F': '#E25AA1',
  'F♯/G♭': '#5AE2E2',
  'G': '#E29E5A',
  'G♯/A♭': '#5A5AE2',
  'A': '#A1E25A',
  'A♯/B♭': '#E25AE2',
  'B': '#5AE29E'
};

// Intervals
const intervals = {
  unison: 0,
  minor2nd: 1,
  major2nd: 2,
  minor3rd: 3,
  major3rd: 4,
  perfect4th: 5,
  tritone: 6,
  perfect5th: 7,
  minor6th: 8,
  major6th: 9,
  minor7th: 10,
  major7th: 11,
  octave: 12
};

// Key signatures
const keySignatures = {
  'C': [],
  'G': ['F♯'],
  'D': ['F♯', 'C♯'],
  'A': ['F♯', 'C♯', 'G♯'],
  'E': ['F♯', 'C♯', 'G♯', 'D♯'],
  'B': ['F♯', 'C♯', 'G♯', 'D♯', 'A♯'],
  'F♯': ['F♯', 'C♯', 'G♯', 'D♯', 'A♯', 'E♯'],
  'C♯': ['F♯', 'C♯', 'G♯', 'D♯', 'A♯', 'E♯', 'B♯'],
  'F': ['B♭'],
  'B♭': ['B♭', 'E♭'],
  'E♭': ['B♭', 'E♭', 'A♭'],
  'A♭': ['B♭', 'E♭', 'A♭', 'D♭'],
  'D♭': ['B♭', 'E♭', 'A♭', 'D♭', 'G♭'],
  'G♭': ['B♭', 'E♭', 'A♭', 'D♭', 'G♭', 'C♭'],
  'C♭': ['B♭', 'E♭', 'A♭', 'D♭', 'G♭', 'C♭', 'F♭']
};

// Animation settings
const animationSettings = {
  duration: 500, // milliseconds
  easing: 'ease-in-out'
};

export { 
  notes, 
  layouts, 
  scales, 
  chords, 
  modes,
  regulars, 
  noteColors, 
  getNoteDisplay, 
  intervals, 
  keySignatures, 
  animationSettings 
};

// keyboard.js

import * as config from './config.js';

export class Keyboard {
    constructor(container) {
        this.container = container;
        this.keyboardElement = null;
        this.keyElements = new Map(); // Store key elements with their note ids
    }

    initialize() {
        this.createKeyboard();
        this.createKeys();
    }

    createKeyboard() {
        this.keyboardElement = document.createElement('div');
        this.keyboardElement.className = 'keyboard';
        this.container.appendChild(this.keyboardElement);
    }

    createKeys() {
        config.notes.forEach((note, noteId) => {
            const keyElement = document.createElement('div');
            keyElement.className = 'key';
            keyElement.setAttribute('data-note-id', noteId);

            const isBlackNote = note.includes('♯') || note.includes('♭');
            keyElement.classList.add(isBlackNote ? 'black' : 'white');

            const noteDisplay = document.createElement('span');
            noteDisplay.className = 'note-display';
            noteDisplay.textContent = config.getNoteDisplay(note, false); // Default to flats

            keyElement.appendChild(noteDisplay);
            this.keyElements.set(noteId, keyElement);
            this.keyboardElement.appendChild(keyElement);
        });
    }

    updateKeyPositions(layout) {
        let whiteKeyIndex = 0;
        layout.forEach((note, index) => {
            const noteId = config.notes.indexOf(note);
            const keyElement = this.keyElements.get(noteId);
            const isBlackNote = note.includes('♯') || note.includes('♭');

            if (isBlackNote) {
                keyElement.style.left = `${whiteKeyIndex * 40 - 10}px`;
            } else {
                keyElement.style.left = `${whiteKeyIndex * 40}px`;
                whiteKeyIndex++;
            }
        });
    }

    updateKeyState(noteId, state, useColors) {
        const keyElement = this.keyElements.get(noteId);
        if (keyElement) {
            const note = config.notes[noteId];
            const isBlackNote = note.includes('♯') || note.includes('♭');
    
            // Update classes based on state
            keyElement.classList.toggle('active', state.active);
            keyElement.classList.toggle('tonic', state.isTonic);
            keyElement.classList.toggle('in-pattern', state.inPattern);
            
            // Update notation
            const noteDisplay = keyElement.querySelector('.note-display');
            noteDisplay.textContent = state.display;
    
            // Update key color
            keyElement.style.backgroundColor = state.color;
    
            // Set text color and weight
            if (useColors) {
                noteDisplay.style.color = isBlackNote ? 'black' : 'white';
                noteDisplay.style.fontWeight = 'bold';
            } else {
                noteDisplay.style.color = isBlackNote ? 'white' : 'black';
                noteDisplay.style.fontWeight = 'normal';
            }
    
            // Additional styling for active state
            if (state.active) {
                noteDisplay.style.color = isBlackNote ? 'white' : 'black';
            }
        }
    }
}

// wheel.js

import * as config from './config.js';

export class Wheel {
    constructor(container) {
        this.container = container;
        if (!this.container) {
            throw new Error('Wheel container not found');
        }
        this.svg = null;
        this.notesGroup = null;
        this.patternGroup = null;
        this.radius = 120;
        this.positions = Array.from({length: 12}, (_, i) => i);
        this.noteElements = new Map(); // Store note elements with their ids
        this.notePositions = new Map(); // Map note IDs to position IDs
    }

    initialize() {
        this.createSVG();
        this.createWheelPositions();
        this.createNotes();
    }
    
    createSVG() {
        this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        this.svg.setAttribute("width", 300);
        this.svg.setAttribute("height", 300);
        this.svg.setAttribute("viewBox", "-150 -150 300 300");
        
        const background = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        background.setAttribute("x", "-150");
        background.setAttribute("y", "-150");
        background.setAttribute("width", "300");
        background.setAttribute("height", "300");
        background.setAttribute("fill", "#f0f0f0");
        this.svg.appendChild(background);

        this.notesGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        this.patternGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        
        this.svg.appendChild(this.notesGroup);
        this.svg.appendChild(this.patternGroup);
        
        this.container.appendChild(this.svg);
    }

    createWheelPositions() {
        const angleStep = (Math.PI * 2) / 12;
        this.positions.forEach(positionId => {
            const angle = positionId * angleStep - Math.PI / 2;
            const x = Math.cos(angle) * this.radius;
            const y = Math.sin(angle) * this.radius;
            
            const positionGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            positionGroup.setAttribute("transform", `translate(${x}, ${y})`);
            positionGroup.setAttribute("data-position-id", positionId);
            
            this.notesGroup.appendChild(positionGroup);
        });
    }

    createNotes() {
        config.notes.forEach((note, noteId) => {
            if (!this.noteElements.has(noteId)) {    
                const noteGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                noteGroup.setAttribute("data-note-id", noteId);

                const noteCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                noteCircle.setAttribute("r", 20);
                noteCircle.setAttribute("fill", "white");
                noteCircle.setAttribute("stroke", "black");
                
                const noteText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                noteText.setAttribute("text-anchor", "middle");
                noteText.setAttribute("dominant-baseline", "central");
                noteText.textContent = config.getNoteDisplay(note, false); // Default to flats
                
                noteGroup.appendChild(noteCircle);
                noteGroup.appendChild(noteText);
                
                this.noteElements.set(noteId, noteGroup);
            }
        });
    }

    updateNotePositions(layout, animate = true) {
        this.notePositions.clear();
        layout.forEach((note, index) => {
            const noteId = config.notes.indexOf(note);
            this.notePositions.set(noteId, index);
        });

        this.notePositions.forEach((positionId, noteId) => {
            const noteGroup = this.noteElements.get(noteId);
            const positionGroup = this.notesGroup.querySelector(`[data-position-id="${positionId}"]`);
            if (!positionGroup) return;
            
            if (animate) {
                noteGroup.animate([
                    { transform: noteGroup.getAttribute("transform") || "translate(0, 0)" },
                    { transform: positionGroup.getAttribute("transform") }
                ], {
                    duration: 500,
                    easing: 'ease-in-out',
                    fill: 'forwards'
                });
            } else {
                noteGroup.setAttribute("transform", positionGroup.getAttribute("transform"));
            }
            
            positionGroup.appendChild(noteGroup);
        });
    }

    rotateWheel(degrees, animate = false) {
        if (animate) {
            this.notesGroup.animate([
                { transform: this.notesGroup.getAttribute("transform") || "rotate(0)" },
                { transform: `rotate(${degrees})` }
            ], {
                duration: 500,
                easing: 'ease-in-out',
                fill: 'forwards'
            });
        } else {
            this.notesGroup.setAttribute("transform", `rotate(${degrees})`);
        }
    }

    updateNoteState(noteId, state, useColors) {
        const noteElement = this.noteElements.get(noteId);
        if (noteElement) {
            const noteCircle = noteElement.querySelector('circle');
            const noteText = noteElement.querySelector('text');
            const note = config.notes[noteId];
            const isBlackNote = note.includes('♯') || note.includes('♭');
    
            // Update fill color
            noteCircle.setAttribute('fill', state.color);
    
            // Update text
            noteText.textContent = state.display;
    
            // Set text color and weight
            if (useColors) {
                noteText.setAttribute('fill', isBlackNote ? 'black' : 'white');
                noteText.setAttribute('font-weight', 'bold');
            } else {
                noteText.setAttribute('fill', isBlackNote ? 'white' : 'black');
                noteText.setAttribute('font-weight', 'normal');
            }
    
            // Update other visual properties as needed
            noteElement.classList.toggle('active', state.active);
            noteElement.classList.toggle('in-pattern', state.inPattern);
        }
    }

    updatePatternShape(pattern) {
        // Clear existing pattern shape
        this.patternGroup.innerHTML = '';

        if (pattern.length > 0) {
            const points = pattern.map(noteIndex => {
                const positionGroup = this.notesGroup.querySelector(`[data-position-id="${noteIndex}"]`);
                const transform = positionGroup.getAttribute("transform");
                const match = transform.match(/translate\((-?\d+\.?\d*),\s*(-?\d+\.?\d*)\)/);
                return match ? `${parseFloat(match[1]) + 150},${parseFloat(match[2]) + 150}` : '';
            }).join(' ');

            const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            polygon.setAttribute("points", points);
            polygon.setAttribute("fill", "rgba(255, 255, 255, 0.2)");
            polygon.setAttribute("stroke", "white");
            polygon.setAttribute("stroke-width", "2");

            this.patternGroup.appendChild(polygon);
        }
    }
}
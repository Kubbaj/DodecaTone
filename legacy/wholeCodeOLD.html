<!DOCTYPE html>
<html>
<head>
<base href="https://dodecapiano.websim.ai/" />
<title>DodecaTone - Multi-mode Synth Visualizer with Scales and Root Notes</title>
<style>
body {
  font-family: Arial, sans-serif;
  background-color: #1a1a1a;
  color: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  min-height: 100vh;
  margin: 0;
  padding: 20px;
  box-sizing: border-box;
}
h1 {
  font-size: 2.5em;
  margin-bottom: 20px;
}
#synth-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 65%;
  position: relative;
}
#toggle-container {
  position: absolute;
  right: 20px; /* Adjust as needed */
  top: 50%;
  transform: translateY(-50%);
  display: flex;
  flex-direction: column;
  align-items: center;
}

#accidental-toggle-container,
#color-toggle-container {
  display: flex;
  align-items: center;
  justify-content: flex-end;
  margin-bottom: 10px;
}

#accidental-toggle-label,
#color-toggle-label {
  margin-right: 10px;
  font-size: 1em;
  color: #fff;
}

.switch {
  position: relative;
  display: inline-block;
  width: 60px;
  height: 34px;
}

.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  transition: .4s;
  border-radius: 34px;
}

.slider:before {
  position: absolute;
  content: "";
  height: 26px;
  width: 26px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  transition: .4s;
  border-radius: 50%;
}

input:checked + .slider {
  background-color: #4CAF50;
}

input:checked + .slider:before {
  transform: translateX(26px);
}

/* Rounded sliders */
.slider.round {
  border-radius: 34px;
}

.slider.round:before {
  border-radius: 50%;
}

#play-scale {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  cursor: pointer;
  transition: transform 0.3s ease;
}

#play-scale:hover {
  transform: translate(-50%, -50%) scale(1.1);
}

#dodecagon-container {
  position: relative;
  margin-bottom: 30px;
}
#dodecagon {
  width: 300px;
  height: 300px;
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  transition: transform 0.5s ease;
}

.note {
  position: absolute;
  width: 50px;
  height: 50px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  cursor: pointer;
  transition: transform 0.5s ease;
}
.note span {
  transition: transform 0.5s ease; /* Add transition for text rotation */
}

#keyboard {
  display: flex;
  margin-top: 30px;
  position: relative;
  height: 150px;
}
.key {
  width: 40px;
  height: 150px;
  border: 1px solid #000;
  margin: 0 2px;
  cursor: pointer;
  position: relative;
}
.key.black {
  height: 90px;
  width: 30px;
  position: absolute;
  z-index: 2;
}
.active, .scale-active {
  filter: brightness(1.5);
}
select {
  margin: 10px;
  padding: 10px;
  font-size: 1em;
  cursor: pointer;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 5px;
  transition: background-color 0.3s ease;
}
select:hover {
  background-color: #45a049;
}
#scale-polygon {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

.note-wrapper {
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
}

@keyframes pulse {
  0% {
    transform: scale(1);
    filter: brightness(1);
  }
  50% {
    transform: scale(1.2);
    filter: brightness(1.5);
  }
  100% {
    transform: scale(1);
    filter: brightness(1);
  }
}

.pulse {
  animation: pulse 0.5s ease;
}
</style>
</head>
<body>
  <h1>WholeCodeOLD</h1>
  <div>
    <select id="mode-select">
      <option value="chromatic">Chromatic</option>
      <option value="fifths">Cycle of Fifths</option>
      <option value="fourths">Cycle of Fourths</option>
    </select>
    <select id="scale-select">
      <option value="none">No Scale</option>
      <option value="chromatic">Chromatic</option>
      <option value="whole_tone">Whole Tone</option>
      <option value="diminished">Diminished</option>
      <option value="augmented">Augmented</option>
      <option value="fifths">Fifths</option>
      <option value="fourths">Fourths</option>
      <option value="major">Major Scale</option>
      <option value="minor">Natural Minor Scale</option>
      <option value="pentatonic_major">Major Pentatonic</option>
      <option value="pentatonic_minor">Minor Pentatonic</option>
      <option value="blues">Blues Scale</option>
    </select>
    <select id="root-select"></select>
  </div>
  <div id="synth-container">
    <div id="dodecagon-container">
      <svg id="scale-polygon"></svg>
      <div id="dodecagon"></div>
      <svg id="play-scale" style="display:none;" viewBox="0 0 100 100" width="40" height="40">
        <polygon points="30,20 70,50 30,80" fill="white"/>
      </svg>
    </div>
    <div id="keyboard"></div>
    <div id="toggle-container">
      <div id="accidental-toggle-container">
        <label for="toggle-accidentals" id="accidental-toggle-label">b / #</label>
        <label class="switch">
          <input type="checkbox" id="toggle-accidentals" checked>
          <span class="slider round"></span>
        </label>
      </div>
      <div id="color-toggle-container">
        <label for="toggle-colors" id="color-toggle-label">Colors</label>
        <label class="switch">
          <input type="checkbox" id="toggle-colors" checked>
          <span class="slider round"></span>
        </label>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
<script>
  // Global variables
  const synth = new Tone.PolySynth(Tone.Synth).toDestination();
  const chromaticNotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  const fifthsNotes = ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'F'];
  const fourthsNotes = ['C', 'F', 'A#', 'D#', 'G#', 'C#', 'F#', 'B', 'E', 'A', 'D', 'G'];
  let currentNotes = chromaticNotes;
  const octave = 4;
  const noteColors = {
    'C': '#E25A5A', 'G': '#E29E5A', 'D': '#E2E25A', 'A': '#A1E25A', 'E': '#5AE25A', 'B': '#5AE29E',
    'F#': '#5AE2E2', 'C#': '#5AA1E2', 'G#': '#5A5AE2', 'D#': '#9E5AE2', 'A#': '#E25AE2', 'F': '#E25AA1'
  };
  let currentMode = 'chromatic';
  let currentScale = 'none';
  let currentRoot = 'C';
  let useFlats = false;
  let useRainbowColors = true;

  const scales = {
    none: [],
    chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
    whole_tone: [0, 2, 4, 6, 8, 10],
    diminished: [0, 3, 6, 9],
    augmented: [0, 4, 8],
    fifths: [0, 7, 2, 9, 4, 11, 6, 1, 8, 3, 10, 5],
    fourths: [0, 5, 10, 3, 8, 1, 6, 11, 4, 9, 2, 7],
    major: [0, 2, 4, 5, 7, 9, 11],
    minor: [0, 2, 3, 5, 7, 8, 10],
    pentatonic_major: [0, 2, 4, 7, 9],
    pentatonic_minor: [0, 3, 5, 7, 10],
    blues: [0, 3, 5, 6, 7, 10]
  };

  const noteDisplay = {
    'C': 'C', 'C#': 'C# / D♭', 'D': 'D', 'D#': 'D# / E♭', 'E': 'E', 'F': 'F', 'F#': 'F# / G♭', 'G': 'G', 'G#': 'G# / A♭', 'A': 'A', 'A#': 'A# / B♭', 'B': 'B',
    'D♭': 'C# / D♭', 'E♭': 'D# / E♭', 'G♭': 'F# / G♭', 'A♭': 'G# / A♭', 'B♭': 'A# / B♭'
  };

  function rotateNotes(root, notesArray) {
    const rootIndex = notesArray.indexOf(root);
    return notesArray.slice(rootIndex).concat(notesArray.slice(0, rootIndex));
  }

  function createDodecagon() {
  const dodecagon = document.getElementById('dodecagon');
  dodecagon.innerHTML = ''; // Clear previous notes
  const angle = 360 / 12;
  const radius = 125;

  // Create notes
  currentNotes.forEach((note, i) => {
    const wrapperEl = document.createElement('div');
    wrapperEl.className = 'note-wrapper';
    const noteEl = document.createElement('div');
    noteEl.className = 'note';
    noteEl.innerHTML = `<span>${note}</span>`;
	noteEl.setAttribute('data-note', note);

    // Apply colors based on toggle state
    if (useRainbowColors) {
      noteEl.style.backgroundColor = noteColors[note];
    } else {
      noteEl.style.backgroundColor = note.includes('#') ? '#5E6266' : '#D8D8D8';
    }

    const theta = (i * angle - 90) * (Math.PI / 180);
    const x = Math.cos(theta) * radius;
    const y = Math.sin(theta) * radius;

    wrapperEl.style.transform = `translate(${x}px, ${y}px)`;
    wrapperEl.appendChild(noteEl);

    // Update these event listeners
    noteEl.addEventListener('mousedown', () => playNoteInCurrentMode(note));
    noteEl.addEventListener('mouseup', () => stopNoteInCurrentMode(note));
    noteEl.addEventListener('mouseleave', () => stopNoteInCurrentMode(note));
    
    dodecagon.appendChild(wrapperEl);
  });

  // Calculate the correct rotation
  const rootIndex = currentNotes.indexOf(currentRoot);
  const rotation = rootIndex * -30; // 30 degrees per note
  dodecagon.style.transform = `rotate(${rotation}deg)`;

  // Counter-rotate the text
  Array.from(dodecagon.getElementsByClassName('note')).forEach((noteEl) => {
    const textSpan = noteEl.querySelector('span');
    textSpan.style.transform = `rotate(${-rotation}deg)`;
  });

  drawScalePolygon();
}

  function playNoteInCurrentMode(note) {
    // Play the note directly, without trying to map it
    playNote(note + octave);
  }

  function stopNoteInCurrentMode(note) {
    // Stop the note directly, without trying to map it
    stopNote(note + octave);
  }

  function switchScale(scale) {
    currentScale = scale;
    updateDodecagon();
  }

  function switchRoot(root) {
  if (root !== currentRoot) {
    currentRoot = root;
    updateDodecagon(true); // true indicates that the root has changed
  }
}

  function updateDodecagon(rootChanged = false) {
  const dodecagon = document.getElementById('dodecagon');
  const noteElements = dodecagon.getElementsByClassName('note');

  Array.from(noteElements).forEach((noteEl, i) => {
    const note = currentNotes[i];
    noteEl.setAttribute('data-note', note);
    
    if (useFlats && noteDisplay[note] && noteDisplay[note].includes(' / ')) {
      noteEl.querySelector('span').textContent = noteDisplay[note].split(' / ')[1]; // Show flat
    } else {
      noteEl.querySelector('span').textContent = noteDisplay[note] ? noteDisplay[note].split(' / ')[0] : note; // Show sharp or natural
    }

    // Apply colors based on toggle state
    if (useRainbowColors) {
      noteEl.style.backgroundColor = noteColors[note];
    } else {
      noteEl.style.backgroundColor = note.includes('#') ? '#5E6266' : '#D8D8D8';
    }
  });
  
  if (rootChanged) {
    // Only rotate if the root has changed
    const rootIndex = currentNotes.indexOf(currentRoot);
    const rotation = rootIndex * -30;
    dodecagon.style.transform = `rotate(${rotation}deg)`;

    // Counter-rotate text
    Array.from(noteElements).forEach((noteEl) => {
      const textSpan = noteEl.querySelector('span');
      textSpan.style.transform = `rotate(${-rotation}deg)`;
    });
  }

  drawScalePolygon();
}

  function createKeyboard() {
    const keyboard = document.getElementById('keyboard');
    keyboard.innerHTML = '';
    const keyMap = 'AWSEDFTGYHUJKOLP;\'';
    let whiteKeyIndex = 0;

    chromaticNotes.forEach((note, i) => {
      const keyEl = document.createElement('div');
      keyEl.className = 'key';
      if (useRainbowColors) {
        keyEl.style.backgroundColor = noteColors[note];
      } else {
        keyEl.style.backgroundColor = note.includes('#') ? '#5E6266' : '#D8D8D8';
      }
      keyEl.setAttribute('data-note', note);  // Assign data attribute
      if (note.includes('#')) {
        keyEl.classList.add('black');
        keyEl.style.left = `${whiteKeyIndex * 44 - 11}px`;
      } else {
        keyEl.style.left = `${whiteKeyIndex * 0}px`;
        whiteKeyIndex++;
      }
      keyboard.appendChild(keyEl);

      const fullNote = note + octave;
      keyEl.addEventListener('mousedown', () => playNoteInCurrentMode(note));
      keyEl.addEventListener('mouseup', () => stopNoteInCurrentMode(note));
      keyEl.addEventListener('mouseleave', () => stopNoteInCurrentMode(note));

      document.addEventListener('keydown', (e) => {
        if (e.key.toUpperCase() === keyMap[i] && !e.repeat) {
          playNoteInCurrentMode(note);
          keyEl.classList.add('active');
        }
      });
      document.addEventListener('keyup', (e) => {
        if (e.key.toUpperCase() === keyMap[i]) {
          stopNoteInCurrentMode(note);
          keyEl.classList.remove('active');
        }
      });
    });
  }

  function playNote(note) {
    synth.triggerAttack(note);
    const noteName = note.slice(0, -1);
    const noteElements = document.querySelectorAll(`.note[data-note="${noteName}"]`);
    noteElements.forEach(el => el.classList.add('active', 'pulse'));
    const keyElements = document.querySelectorAll(`.key[data-note="${noteName}"]`);
    keyElements.forEach(el => el.classList.add('active', 'pulse'));
  }

  function stopNote(note) {
    synth.triggerRelease(note);
    const noteName = note.slice(0, -1);
    const noteElements = document.querySelectorAll(`.note[data-note="${noteName}"]`);
    noteElements.forEach(el => el.classList.remove('active', 'pulse'));
    const keyElements = document.querySelectorAll(`.key[data-note="${noteName}"]`);
    keyElements.forEach(el => el.classList.remove('active', 'pulse'));
  }

  function drawScalePolygon() {
    const svg = document.getElementById('scale-polygon');
    svg.innerHTML = '';

    if (currentScale === 'none') {
      document.getElementById('play-scale').style.display = 'none';
      return;
    }

    const scaleNotes = scales[currentScale];
    const radius = 112;
    const rootIndex = currentNotes.indexOf(currentRoot);
    const points = scaleNotes.map(noteIndex => {
      const note = chromaticNotes[(chromaticNotes.indexOf(currentRoot) + noteIndex) % 12];
      const i = (currentNotes.indexOf(note) - rootIndex + 12) % 12;
      const angle = (i * 30 - 90) * (Math.PI / 180);
      const x = Math.cos(angle) * radius + 150;
      const y = Math.sin(angle) * radius + 150;
      return `${x},${y}`;
    }).join(' ');

    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    polygon.setAttribute('points', points);
    polygon.setAttribute('fill', 'rgba(255, 255, 255, 0.1)');
    polygon.setAttribute('stroke', 'white');
    polygon.setAttribute('stroke-width', '2');
    svg.appendChild(polygon);

    // Show and position the play button
    const playButton = document.getElementById('play-scale');
    playButton.style.display = 'block';
  }

  function playScaleNotes() {
    const scaleNotes = scales[currentScale];
    let previousNote = null;
    const notesToPlay = scaleNotes.map(noteIndex => {
      const note = chromaticNotes[(chromaticNotes.indexOf(currentRoot) + noteIndex) % 12];
      const octaveAdjustedNote = adjustOctave(note, previousNote);
      previousNote = octaveAdjustedNote;
      return octaveAdjustedNote;
    });

    // Add the final note an octave up
    const finalNote = notesToPlay[0];
    const finalNoteOctaveUp = finalNote.slice(0, -1) + (parseInt(finalNote.slice(-1), 10) + 1);
    notesToPlay.push(finalNoteOctaveUp);

    let currentIndex = 0;

    function playNextNote() {
      if (currentIndex < notesToPlay.length) {
        const note = notesToPlay[currentIndex];
        synth.triggerAttackRelease(note, '8n');

        // Highlight the corresponding note elements
        const noteName = note.slice(0, -1);
        const noteElements = document.querySelectorAll(`.note[data-note="${noteName}"]`);
        const keyElements = document.querySelectorAll(`.key[data-note="${noteName}"]`);

        noteElements.forEach(el => {
          el.classList.add('active', 'pulse');
          setTimeout(() => {
            el.classList.remove('active', 'pulse');
          }, 500); // Adjust the delay to match the animation duration
        });

        keyElements.forEach(el => {
          el.classList.add('active', 'pulse');
          setTimeout(() => {
            el.classList.remove('active', 'pulse');
          }, 500); // Adjust the delay to match the animation duration
        });

        currentIndex++;
        setTimeout(playNextNote, 500); // Adjust the delay as needed
      }
    }

    playNextNote();
  }

  function adjustOctave(currentNote, previousNote) {
    if (!previousNote) {
      return currentNote + octave;
    }

    const currentNoteIndex = chromaticNotes.indexOf(currentNote);
    const previousNoteIndex = chromaticNotes.indexOf(previousNote.slice(0, -1));
    const previousOctave = parseInt(previousNote.slice(-1), 10);

    let newOctave = previousOctave;
    if (currentNoteIndex <= previousNoteIndex) {
      newOctave += 1;
    }

    return currentNote + newOctave;
  }

  function populateRootSelect() {
    const rootSelect = document.getElementById('root-select');
    rootSelect.innerHTML = ''; // Clear previous options
    chromaticNotes.forEach(note => {
      const option = document.createElement('option');
      option.value = note;
      option.textContent = note;
      rootSelect.appendChild(option);
    });
  }

  function toggleAccidentals() {
    useFlats = !useFlats;
    updateDodecagon();
    createKeyboard();
  }

  document.getElementById('toggle-accidentals').addEventListener('change', toggleAccidentals);

  function toggleColors() {
    useRainbowColors = !useRainbowColors;
    updateNoteColors();
  }

function getWholeTonePairs(rootNote) {
  const chromaticIndex = chromaticNotes.indexOf(rootNote);
  const isEvenRoot = chromaticIndex % 2 === 0;
  const pairs = [];

  for (let i = 0; i < 12; i++) {
    if ((i % 2 !== 0) === isEvenRoot) {
      const swapIndex = (i + 6) % 12;
      pairs.push([i, swapIndex]);
    }
  }

  return pairs;
}

function animateModeChange(newMode) {
  const dodecagon = document.getElementById('dodecagon');
  const angle = 360 / 12;
  const radius = 125;

  const chromaticPairs = getWholeTonePairs(currentRoot);

  chromaticPairs.forEach(([a, b]) => {
    const noteA = dodecagon.children[a].querySelector('.note');
    const noteB = dodecagon.children[b].querySelector('.note');

    const thetaA = (a * angle - 90) * (Math.PI / 180);
    const xA = Math.cos(thetaA) * radius;
    const yA = Math.sin(thetaA) * radius;

    const thetaB = (b * angle - 90) * (Math.PI / 180);
    const xB = Math.cos(thetaB) * radius;
    const yB = Math.sin(thetaB) * radius;

    noteA.style.transition = 'transform 1s ease';
    noteB.style.transition = 'transform 1s ease';

    if (newMode === 'fifths') {
      noteA.style.transform = `translate(${xB * 2}px, ${yB * 2}px)`;
      noteB.style.transform = `translate(${xA * 2}px, ${yA * 2}px)`;
    } else if (newMode === 'chromatic') {
      noteA.style.transform = `translate(${-xA * 2}px, ${-yA * 2}px)`;
      noteB.style.transform = `translate(${-xB * 2}px, ${-yB * 2}px)`;
    }
  });

  setTimeout(() => {
    chromaticPairs.forEach(([a, b]) => {
      const noteAWrapper = dodecagon.children[a];
      const noteBWrapper = dodecagon.children[b];
      const noteA = noteAWrapper.querySelector('.note');
      const noteB = noteBWrapper.querySelector('.note');

      noteAWrapper.appendChild(noteB);
      noteBWrapper.appendChild(noteA);

      noteA.style.transition = '';
      noteB.style.transition = '';
      noteA.style.transform = '';
      noteB.style.transform = '';
    });

    currentNotes = newMode === 'fifths' ? fifthsNotes : chromaticNotes;
    createDodecagon();
    createKeyboard();
  }, 1000);
}

function switchMode(mode) {
  if ((mode === 'fifths' && currentMode === 'chromatic') || (mode === 'chromatic' && currentMode === 'fifths')) {
    animateModeChange(mode);
  }
  currentMode = mode;
  setTimeout(() => {
    switch (mode) {
      case 'chromatic':
        currentNotes = chromaticNotes;
        break;
      case 'fifths':
        currentNotes = fifthsNotes;
        break;
      case 'fourths':
        currentNotes = fourthsNotes;
        break;
    }
    updateDodecagon(false); // false indicates that the root hasn't changed
    createKeyboard();
  }, 1000);
}





  function updateNoteColors() {
    const whiteNoteColor = useRainbowColors ? null : '#D8D8D8';
    const blackNoteColor = useRainbowColors ? null : '#5E6266';

    // Update dodecagon note colors
    const noteElements = document.querySelectorAll('.note');
    noteElements.forEach(noteEl => {
      const note = noteEl.getAttribute('data-note');
      if (useRainbowColors) {
        noteEl.style.backgroundColor = noteColors[note];
      } else {
        noteEl.style.backgroundColor = note.includes('#') ? blackNoteColor : whiteNoteColor;
      }
    });

    // Update keyboard note colors
    const keyElements = document.querySelectorAll('.key');
    keyElements.forEach(keyEl => {
      const note = keyEl.getAttribute('data-note');
      if (useRainbowColors) {
        keyEl.style.backgroundColor = noteColors[note];
      } else {
        keyEl.style.backgroundColor = note.includes('#') ? blackNoteColor : whiteNoteColor;
      }
    });
  }

  // Initialize with default note colors
  updateNoteColors();

  // Initial calls to create the dodecagon and keyboard
createDodecagon();
createKeyboard();
populateRootSelect();

// Event listeners
document.getElementById('mode-select').addEventListener('change', (e) => switchMode(e.target.value));
document.getElementById('scale-select').addEventListener('change', (e) => switchScale(e.target.value));
document.getElementById('root-select').addEventListener('change', (e) => switchRoot(e.target.value));
document.getElementById('play-scale').addEventListener('click', playScaleNotes);
document.getElementById('toggle-accidentals').addEventListener('change', toggleAccidentals);
document.getElementById('toggle-colors').addEventListener('change', toggleColors);

</script>
</body>
</html>


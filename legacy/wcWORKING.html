<!-- index.html -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DodecaTone</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>DodecaTone (4.x)</h1>
    </header>
    <div id="options-container">
        <div class="select-group">
            <label for="layout-select">Layout:</label>
            <select id="layout-select">
                <option value="chromatic">Chromatic</option>
                <option value="fifths">Fifths</option>
                <option value="fourths">Fourths</option>
            </select>
        </div>

        <div id="tonic-selector">
            <button id="decrease-tonic">&lt;</button>
            <span id="current-tonic">C</span>
            <button id="increase-tonic">&gt;</button>
        </div>

        <div class="select-group">
            <label for="pattern-select">Pattern:</label>
            <select id="pattern-select">
                <option value="none">None</option>
                <option value="major">Major Scale</option>
                <option value="minor">Minor Scale</option>
                <!-- Add more scale options here -->
            </select>
        </div>
    </div>

    <div id="content-container">
        <div id="main-content">
            <div id="wheel-container" class="wheel">
                <!-- Wheel will be inserted here by JavaScript -->
            </div>
            <div id="keyboard-container">
                <!-- Keyboard will be inserted here by JavaScript -->
            </div>
        </div>
        <div id="toggles-panel">
            <h3>Settings</h3>
            <div class="toggle-group">
                <label for="toggle-sharps">Use Sharps:</label>
                <input type="checkbox" id="toggle-sharps">
            </div>
            <div class="toggle-group">
                <label for="toggle-colors">Use Colors:</label>
                <input type="checkbox" id="toggle-colors">
            </div>
            <div class="toggle-group">
                <label for="toggle-animate">Animation:</label>
                <input type="checkbox" id="toggle-animate">
            </div>
            <button id="toggle-debug">Toggle Debug Dashboard</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script type="module" src="app.js"></script>
</body>
</html>

<!-- styles.css -->
/* General Styles */
body {
    font-family: Arial, sans-serif;
    background-color: #f0f0f0;
    margin: 0;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    position: relative;
}

header {
    position: absolute;
    top: 10px;
    left: 20px;
}

h1 {
    margin: 0;
    font-size: 1.5em;
}

/* Options Container */
#options-container {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 25px;
    width: 100%;
    max-width: 800px;
    margin: 60px 0 20px;
}

.select-group {
    display: flex;
    align-items: center;
}

.select-group label {
    margin-right: 5px;
}

#tonic-selector {
    display: flex;
    align-items: center;
}

#tonic-selector button {
    font-size: 16px;
    padding: 5px 10px;
    margin: 0 5px;
}

#current-tonic {
    font-size: 18px;
    font-weight: bold;
    margin: 0 5px;
}

/* Form Elements */
select, button {
    padding: 5px 10px;
    margin: 5px;
}

input[type="checkbox"] {
    margin-right: 0;
}

/* Content Container */
#content-container, #main-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    max-width: 800px;
}

/* Wheel Container */
#wheel-container {
    width: 300px;
    height: 300px;
    margin-bottom: 20px;
    border: 1px solid black;
}

#wheel-container svg {
    width: 100%;
    height: 100%;
    transform-box: fill-box;
}

#wheel-container svg * {
    visibility: visible !important;
}

.note circle {
    stroke-width: 2;
}

.note text {
    font-size: 14px;
}

wheel .note {
    transition: transform 0.2s ease, opacity 0.2s ease;
}

.wheel .note circle {
    transition: r 0.2s ease;
}

/* Keyboard Container */
#keyboard-container {
    width: 600px;
    height: 150px;
    display: flex;
    justify-content: center;
    border: 1px solid black;
}

.keyboard {
    position: relative;
    width: 100%;
    height: 100%;
    overflow-x: auto;
    overflow-y: hidden;
}

/* Key Styles */
.key {
    position: absolute;
    width: 40px;
    height: 150px;
    border: 1px solid #000;
    box-sizing: border-box;
    display: flex;
    justify-content: center;
    align-items: flex-end;
    padding-bottom: 10px;
    cursor: pointer;
}

.key.white {
    background-color: #fff;
    z-index: 1;
}

.key.black {
    background-color: #333;
    height: 100px;
    width: 20px;
    z-index: 2;
}

.note-display {
    font-size: 12px;
    color: #000;
    position: absolute;
    bottom: 5px;
    left: 50%;
    transform: translateX(-50%);
}

.key.black .note-display {
    color: #fff;
}

/* Animation Styles */
.key {
    transition: transform 0.1s ease, filter 0.1s ease;
}

.key.active {
    transform: scale(0.95);
    filter: brightness(0.8);
}

.key.colored, .note.colored {
    transition: none;
}

.key.colored.active {
    filter: brightness(0.8);
}

/* Toggles Panel */
#toggles-panel {
    position: absolute;
    top: 150px;
    right: 20px;
    width: 200px;
    padding: 10px;
    background-color: #f8f8f8;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

#toggles-panel h3 {
    margin-top: 0;
}

.toggle-group {
    margin-bottom: 10px;
}

.toggle-group label {
    display: block;
    margin-bottom: 5px;
}

#toggle-debug {
    margin-top: 10px;
    width: 100%;
}

<!-- config.js -->
// config.js

// Basic note array
const notes = ['C', 'C♯/D♭', 'D', 'D♯/E♭', 'E', 'F', 'F♯/G♭', 'G', 'G♯/A♭', 'A', 'A♯/B♭', 'B'];

const keyboardNotes = [
  ...notes,
  ...notes.map(note => note)
];

// Function to generate layout based on interval
const generateLayout = (interval) => {
  return Array.from({ length: 12 }, (_, i) => notes[(i * interval) % 12]);
};

// Layouts
const layouts = {
  chromatic: notes,
  fifths: generateLayout(7),
  fourths: generateLayout(5)
};

// Function to get note display based on sharp/flat preference
const getNoteDisplay = (note, useSharps) => {
  if (note.includes('/')) {
    return useSharps ? note.slice(0, 2) : note.slice(-2);
  }
  return note;
};

// Scales
const scales = {
  none: [],
  chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
  major: [0, 2, 4, 5, 7, 9, 11],
  minor: [0, 2, 3, 5, 7, 8, 10],
  harmonicMinor: [0, 2, 3, 5, 7, 8, 11],
  melodicMinor: [0, 2, 3, 5, 7, 9, 11],
  pentatonicMajor: [0, 2, 4, 7, 9],
  pentatonicMinor: [0, 3, 5, 7, 10],
  blues: [0, 3, 5, 6, 7, 10],
  wholeTone: [0, 2, 4, 6, 8, 10],
  diminished: [0, 2, 3, 5, 6, 8, 9, 11],
  augmented: [0, 3, 4, 7, 8, 11]
};

// Chords
const chords = {
  major: [0, 4, 7],
  minor: [0, 3, 7],
  diminished: [0, 3, 6],
  augmented: [0, 4, 8],
  sus2: [0, 2, 7],
  sus4: [0, 5, 7],
  major7: [0, 4, 7, 11],
  minor7: [0, 3, 7, 10],
  dominant7: [0, 4, 7, 10],
  diminished7: [0, 3, 6, 9],
  halfDiminished7: [0, 3, 6, 10]
};

// Modes
const modes = {
  ionian: scales.major,
  dorian: [0, 2, 3, 5, 7, 9, 10],
  phrygian: [0, 1, 3, 5, 7, 8, 10],
  lydian: [0, 2, 4, 6, 7, 9, 11],
  mixolydian: [0, 2, 4, 5, 7, 9, 10],
  aeolian: scales.minor,
  locrian: [0, 1, 3, 5, 6, 8, 10]
};

// Regulars
const regulars = {
  one: scales.chromatic,
  two: scales.wholeTone,
  three: chords.diminished7,
  four: chords.augmented,
  five: layouts.fourths,
  six: [0,6]
}

// Note colors (ordered chromatically)
const noteColors = {
  'C': '#E25A5A',
  'C♯/D♭': '#5AA1E2',
  'D': '#E2E25A',
  'D♯/E♭': '#9E5AE2',
  'E': '#5AE25A',
  'F': '#E25AA1',
  'F♯/G♭': '#5AE2E2',
  'G': '#E29E5A',
  'G♯/A♭': '#5A5AE2',
  'A': '#A1E25A',
  'A♯/B♭': '#E25AE2',
  'B': '#5AE29E'
};

// Intervals
const intervals = {
  unison: 0,
  minor2nd: 1,
  major2nd: 2,
  minor3rd: 3,
  major3rd: 4,
  perfect4th: 5,
  tritone: 6,
  perfect5th: 7,
  minor6th: 8,
  major6th: 9,
  minor7th: 10,
  major7th: 11,
  octave: 12
};

// Key signatures
const keySignatures = {
  'C': [],
  'G': ['F♯'],
  'D': ['F♯', 'C♯'],
  'A': ['F♯', 'C♯', 'G♯'],
  'E': ['F♯', 'C♯', 'G♯', 'D♯'],
  'B': ['F♯', 'C♯', 'G♯', 'D♯', 'A♯'],
  'F♯': ['F♯', 'C♯', 'G♯', 'D♯', 'A♯', 'E♯'],
  'C♯': ['F♯', 'C♯', 'G♯', 'D♯', 'A♯', 'E♯', 'B♯'],
  'F': ['B♭'],
  'B♭': ['B♭', 'E♭'],
  'E♭': ['B♭', 'E♭', 'A♭'],
  'A♭': ['B♭', 'E♭', 'A♭', 'D♭'],
  'D♭': ['B♭', 'E♭', 'A♭', 'D♭', 'G♭'],
  'G♭': ['B♭', 'E♭', 'A♭', 'D♭', 'G♭', 'C♭'],
  'C♭': ['B♭', 'E♭', 'A♭', 'D♭', 'G♭', 'C♭', 'F♭']
};

// Animation settings
const animationSettings = {
  duration: 500, // milliseconds
  easing: 'ease-in-out'
};

export { 
  notes, 
  keyboardNotes,
  layouts, 
  scales, 
  chords, 
  modes,
  regulars, 
  noteColors, 
  getNoteDisplay, 
  intervals, 
  keySignatures, 
  animationSettings 
};

<!-- app.js -->
// app.js

import * as config from './config.js';
import { Wheel } from './wheel.js';
import { Keyboard } from './keyboard.js';
import { debugTracker, toggleDebugDashboard } from './debugPanel.js';

// Initialize Tone.js
const synth = new Tone.PolySynth(Tone.Synth).toDestination();

// Global state
let currentLayout = 'chromatic';
let currentPattern = 'none';
let currentTonic = 'C';
let useSharps = false;
let useColors = false;
let animate = false;


// Initialize components
const wheel = new Wheel(document.getElementById('wheel-container'));
const keyboard = new Keyboard(document.getElementById('keyboard-container'));

function updateLayout(newLayout) {
    currentLayout = newLayout;
   // wheel.updateNotePositions(config.layouts[currentLayout], true);
    updateAllNoteStates();
}

// TOGGLES

function toggleSharps() {
    useSharps = !useSharps;
    console.log("Toggled sharps. New value:", useSharps);
    updateAllNoteStates();
}

function toggleColors() {
    useColors = !useColors;
    console.log("Toggled colors. New value:", useColors);
    updateAllNoteStates();
}

function toggleAnimation() {
    animate = !animate;
    console.log("Toggled animation. New value:", animate);
}


function updateAllNoteStates() {
    console.log("Updating all note states. animate:", animate, "useColors:", useColors, "useSharps:", useSharps);
    config.keyboardNotes.forEach((note, noteId) => {
        const baseNoteId = noteId % 12;
        const isActive = wheel.noteElements.get(baseNoteId)?.classList.contains('active') || 
                         keyboard.keyElements.get(noteId)?.classList.contains('active');
        const state = getNoteState(config.notes[baseNoteId], isActive);
        console.log(`Updating state for note ${note}:`, state);
        if (noteId < 12) {
            wheel.updateNoteState(noteId, state, useColors, animate);
        }
        keyboard.updateKeyState(noteId, state, useColors, animate);
    });
}

function getNoteState(note, isActive = false) {
    const baseNote = note || config.notes[config.notes.indexOf(note) % 12];
    return {
        display: config.getNoteDisplay(baseNote, useSharps),
        color: useColors ? config.noteColors[baseNote] : (baseNote.includes('/') ? 'black' : 'white'),
        active: isActive
    };
}

// PLAYBACK

// In app.js
function playNote(toneNote) {
    synth.triggerAttack(toneNote);
    updateNoteState(toneNote, true);  // Always set to active when playing
}

function stopNote(toneNote) {
    synth.triggerRelease(toneNote);
    updateNoteState(toneNote, false);  // Always set to inactive when stopping
}

function updateNoteState(toneNote, isActive) {
    // Update keyboard
    const keyElement = document.querySelector(`.keyboard [data-tone-note="${toneNote}"]`);
    if (keyElement) {
        const noteId = parseInt(keyElement.dataset.noteId);
        const baseNoteId = noteId % 12;
        const state = getNoteState(config.notes[baseNoteId], isActive);
        keyboard.updateKeyState(noteId, state, useColors, animate);
    }

    // Update wheel
    const wheelElement = document.querySelector(`.wheel [data-tone-note="${toneNote}"]`);
    if (wheelElement) {
        const noteId = parseInt(wheelElement.dataset.noteId);
        const state = getNoteState(config.notes[noteId], isActive);
        wheel.updateNoteState(noteId, state, useColors, animate);
    }
}

document.addEventListener('DOMContentLoaded', () => {
    wheel.initialize();
    keyboard.initialize();
    setupDebugTracker();

    // updateLayout(currentLayout);

    // Event listeners
    document.getElementById('layout-select').addEventListener('change', (e) => updateLayout(e.target.value));
    document.getElementById('toggle-animate').addEventListener('change', toggleAnimation);
    document.getElementById('toggle-sharps').addEventListener('change', toggleSharps);
    document.getElementById('toggle-colors').addEventListener('change', toggleColors);
    document.getElementById('toggle-debug').addEventListener('click', toggleDebugDashboard);
    

    
    // PLAYBACK

    wheel.container.addEventListener('mousedown', (e) => {
        const noteElement = e.target.closest('[data-tone-note]');
        if (noteElement) {
            const toneNote = noteElement.getAttribute('data-tone-note');
            playNote(toneNote);
        }
    });
    
    wheel.container.addEventListener('mouseup', (e) => {
        const noteElement = e.target.closest('[data-tone-note]');
        if (noteElement) {
            const toneNote = noteElement.getAttribute('data-tone-note');
            stopNote(toneNote);
        }
    });

    keyboard.keyboardElement.addEventListener('mousedown', (e) => {
        const keyElement = e.target.closest('[data-tone-note]');
        if (keyElement) {
            const toneNote = keyElement.getAttribute('data-tone-note');
            playNote(toneNote);
        }
    });
    
    keyboard.keyboardElement.addEventListener('mouseup', (e) => {
        const keyElement = e.target.closest('[data-tone-note]');
        if (keyElement) {
            const toneNote = keyElement.getAttribute('data-tone-note');
            stopNote(toneNote);
        }
    });
});
// DEBUG STUFF

function setupDebugTracker() {
    debugTracker.track('useSharps', () => useSharps);
    debugTracker.track('useColors', () => useColors);
    debugTracker.track('animate', () => animate);
    debugTracker.track('wheelNoteElements', () => wheel.noteElements.size);
    debugTracker.track('wheelNotePositions', () => wheel.notePositions.size);
    debugTracker.track('keyboardKeyElements', () => keyboard.keyElements.size);
}



export { playNote, stopNote };

<!-- keyboard.js -->
// keyboard.js

import * as config from './config.js';

export class Keyboard {
    constructor(container) {
        this.container = container;
        this.keyboardElement = document.createElement('div');
        this.keyboardElement.className = 'keyboard';
        this.keyElements = new Map();
        this.keyWidth = 25; // Base width for black keys
        this.keyWidths = { C: 1.5, D: 2, E: 1.5, F: 1.5, G: 2, A: 2, B: 1.5 };
    }

    initialize() {
        this.container.appendChild(this.keyboardElement);
        this.createKeys();
    }

    createKeys() {
        let position = 0;
        
        config.keyboardNotes.forEach((note, index) => {
            const keyElement = document.createElement('div');
            const isBlackNote = note.includes('/');
            
            keyElement.className = `key ${isBlackNote ? 'black' : 'white'}`;
            keyElement.dataset.noteId = index;

            // Calculate toneNote
            const baseTone = isBlackNote ? note.charAt(0) + '#' : note.charAt(0);
            keyElement.dataset.toneNote = `${baseTone}${index < 12 ? 4 : 5}`;

            // Set the width and position of the key
            const width = this.keyWidth * (isBlackNote ? 1 : this.keyWidths[note.charAt(0)]);
            keyElement.style.width = `${width}px`;
            keyElement.style.left = `${position + (isBlackNote ? -this.keyWidth / 2 : 0)}px`;
            
            if (!isBlackNote) position += width;

            const noteDisplay = document.createElement('span');
            noteDisplay.className = 'note-display';
            noteDisplay.textContent = config.getNoteDisplay(note, false);

            keyElement.appendChild(noteDisplay);
            this.keyElements.set(index, keyElement);
            this.keyboardElement.appendChild(keyElement);
        });
    }

    updateKeyState(noteId, state, useColors, animate) {
        const keyElement = this.keyElements.get(noteId);
        if (keyElement) {
            const isBlackNote = config.keyboardNotes[noteId].includes('/');
            const noteDisplay = keyElement.querySelector('.note-display');
            keyElement.classList.toggle('active', state.active);
            noteDisplay.textContent = state.display;
    
            if (useColors) {
                keyElement.style.backgroundColor = state.color;
                noteDisplay.style.color = isBlackNote ? 'black' : 'white';
                noteDisplay.style.fontWeight = 'bold';
            } else {
                keyElement.style.backgroundColor = isBlackNote ? 'black' : 'white';
                noteDisplay.style.color = isBlackNote ? 'white' : 'black';
                noteDisplay.style.fontWeight = 'normal';
            }
    
            if (animate) {
                console.log(`Keyboard: Toggling active class for key ${noteId}. Active:`, state.active);
                keyElement.classList.toggle('active', state.active);
            } else {
                console.log(`Keyboard: Removing active class for key ${noteId}`);
                keyElement.classList.remove('active');
            }
        }
    }
}

<!-- wheel.js -->
// wheel.js

import * as config from './config.js';

export class Wheel {
    constructor(container) {
        this.container = container;
        this.svg = null;
        this.notesGroup = null;
        this.patternGroup = null;
        this.radius = 120;
        this.positions = Array.from({length: 12}, (_, i) => i);
        this.noteElements = new Map(); // Store note elements with their ids
        this.notePositions = new Map(); // Map note IDs to position IDs

        this.animationParams = {
            scale: 0.95,
            brightness: 0.8,
            originalRadius: 20,
            duration: 200 // milliseconds
        };
    }

    initialize() {
        this.createSVG();
        this.createWheelPositions();
        this.createNotes();
    }
    
    createSVG() {
        this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        this.svg.setAttribute("width", 300);
        this.svg.setAttribute("height", 300);
        this.svg.setAttribute("viewBox", "-150 -150 300 300");
        
        const background = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        background.setAttribute("x", "-150");
        background.setAttribute("y", "-150");
        background.setAttribute("width", "300");
        background.setAttribute("height", "300");
        background.setAttribute("fill", "#f0f0f0");
        this.svg.appendChild(background);

        this.notesGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        this.patternGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        
        this.svg.appendChild(this.notesGroup);
        this.svg.appendChild(this.patternGroup);
        
        this.container.appendChild(this.svg);
    }

    createWheelPositions() {
        const angleStep = (Math.PI * 2) / 12;
        const fragment = document.createDocumentFragment();
    
        this.positions.forEach(positionId => {
            const angle = positionId * angleStep - Math.PI / 2;
            const [x, y] = [Math.cos(angle), Math.sin(angle)].map(coord => coord * this.radius);
            
            const positionGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            positionGroup.setAttribute("transform", `translate(${x}, ${y})`);
            positionGroup.dataset.positionId = positionId;
            
            fragment.appendChild(positionGroup);
        });
    
        this.notesGroup.appendChild(fragment);
    }

    createNotes() {
        const fragment = document.createDocumentFragment();
        const angleStep = (Math.PI * 2) / 12;
    
        config.notes.forEach((note, noteId) => {
            const noteGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            noteGroup.dataset.noteId = noteId;
            noteGroup.style.cursor = "pointer";
    
            const noteCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            noteCircle.setAttribute("r", "20");
            noteCircle.setAttribute("stroke", "black");
            
            const noteText = document.createElementNS("http://www.w3.org/2000/svg", "text");
            noteText.setAttribute("text-anchor", "middle");
            noteText.setAttribute("dominant-baseline", "central");
            
            noteGroup.append(noteCircle, noteText);
    
            // Calculate position
            const angle = noteId * angleStep - Math.PI / 2;
            const x = Math.cos(angle) * this.radius;
            const y = Math.sin(angle) * this.radius;
           
            const transform = `translate(${x.toFixed(2)}, ${y.toFixed(2)})`;
            noteGroup.setAttribute("transform", transform);
            noteGroup.setAttribute("data-original-transform", transform);
            
            // Calculate toneNote
            const isBlackNote = note.includes('/');
            const baseTone = isBlackNote ? note.charAt(0) + '#' : note.charAt(0);
            const toneNote = `${baseTone}4`;  // All notes in the wheel are in octave 4
            noteGroup.dataset.toneNote = toneNote

            fragment.appendChild(noteGroup);
            this.noteElements.set(noteId, noteGroup);
    
            // Set initial state
            const initialState = {
                display: config.getNoteDisplay(note, false),
                color: isBlackNote ? 'black' : 'white',
                active: false,
                inPattern: false
            };
            
            this.updateNoteState(noteId, initialState, false, false);
        });
    
        this.notesGroup.appendChild(fragment);
    }

    animateNote(noteElement, isActive) {
        const noteCircle = noteElement.querySelector('circle');
        const { scale, brightness, originalRadius, duration } = this.animationParams;
    
        // Get the original transform (which should be the translation)
        const originalTransform = noteElement.getAttribute('data-original-transform') || noteElement.getAttribute('transform');
    
        // Store the original transform if we haven't already
        if (!noteElement.hasAttribute('data-original-transform')) {
            noteElement.setAttribute('data-original-transform', originalTransform);
        }
    
        // Set transition
        noteElement.style.transition = `filter ${duration}ms ease`;
        noteCircle.style.transition = `r ${duration}ms ease`;
    
        if (isActive) {
            noteElement.setAttribute('transform', `${originalTransform} scale(${scale})`);
            noteElement.style.filter = `brightness(${brightness})`;
            noteCircle.setAttribute('r', originalRadius * scale);
        } else {
            noteElement.setAttribute('transform', originalTransform);
            noteElement.style.filter = 'brightness(1)';
            noteCircle.setAttribute('r', originalRadius);
        }
    
        console.log('Note data:', {
            noteId: noteElement.dataset.noteId,
            toneNote: noteElement.dataset.toneNote,
            isActive,
            transform: noteElement.getAttribute('transform'),
            filter: noteElement.style.filter,
            radius: noteCircle.getAttribute('r')
        });
    }

    updateNoteState(noteId, state, useColors, animate) {
        const noteElement = this.noteElements.get(noteId);
        if (noteElement) {
            const noteCircle = noteElement.querySelector('circle');
            const noteText = noteElement.querySelector('text');
            const note = config.notes[noteId];
            const isBlackNote = note.includes('/');
            noteElement.classList.toggle('active', state.active);
            noteCircle.setAttribute('fill', state.color);
            noteText.textContent = state.display;
    
            noteText.setAttribute('fill', useColors ? (isBlackNote ? 'black' : 'white') : (isBlackNote ? 'white' : 'black'));
            noteText.setAttribute('font-weight', useColors ? 'bold' : 'normal');
    
            if (animate) {
                this.animateNote(noteElement, state.active);
            }
        }
    }
}

<!-- debugPanel.js -->
// debugPanel.js

class DebugTracker {
    constructor() {
        this.trackedVars = {};
    }

    track(name, getter) {
        Object.defineProperty(this.trackedVars, name, {
            get: getter,
            enumerable: true
        });
    }

    getAll() {
        const result = {};
        for (const [key, value] of Object.entries(this.trackedVars)) {
            result[key] = value;
        }
        return result;
    }
}

const debugTracker = new DebugTracker();

let debugMode = false;
let updateInterval = null;

function toggleDebugDashboard() {
    debugMode = !debugMode;
    const dashboard = document.getElementById('debug-dashboard') || createDebugDashboard();
    
    if (debugMode) {
        dashboard.style.display = 'block';
        updateInterval = setInterval(updateDebugDashboard, 250); // Update 4 times per second
    } else {
        dashboard.style.display = 'none';
        if (updateInterval) {
            clearInterval(updateInterval);
            updateInterval = null;
        }
    }
    
    if (debugMode) {
        updateDebugDashboard();
    }
}

function createDebugDashboard() {
    const dashboard = document.createElement('div');
    dashboard.id = 'debug-dashboard';
    dashboard.style.cssText = `
        position: fixed;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-family: monospace;
        z-index: 9999;
        display: none;
        pointer-events: none;
        user-select: none;
        max-width: 300px;
        overflow-y: auto;
        max-height: 90vh;
    `;
    document.body.appendChild(dashboard);
    return dashboard;
}

function updateDebugDashboard() {
    const dashboard = document.getElementById('debug-dashboard');
    if (!dashboard) return;
    
    const state = debugTracker.getAll();
    
    dashboard.innerHTML = `
        <h3>Debug Dashboard</h3>
        <pre>
${Object.entries(state).map(([key, value]) => `${key}: ${JSON.stringify(value)}`).join('\n')}

        </pre>
    `;
}

export { debugTracker, toggleDebugDashboard };